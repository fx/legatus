<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gatus Status</title>
    <link rel="stylesheet" href="/styles.css" />
    <script src="https://unpkg.com/htmx.org@2.0.4"></script>
    <script src="https://unpkg.com/mustache@4.2.0/mustache.min.js"></script>
    <script src="https://unpkg.com/htmx-ext-client-side-templates@2.0.1/client-side-templates.js"></script>
  </head>
  <body>
    <!-- Mustache template for endpoints -->
    <template id="endpoints-template">
      <div class="status-grid">
        {{#endpoints}}
        <button
          type="button"
          class="status-square status-{{statusClass}}"
          aria-label="{{name}}{{#group}} ({{group}}){{/group}}: {{statusLabel}}"
          popovertarget="popover-{{index}}"
        ></button>
        <div
          id="popover-{{index}}"
          popover="auto"
          class="status-popover"
        >
          <div class="popover-header">
            <div>
              <h3 class="popover-name">{{name}}</h3>
              {{#group}}
              <p class="popover-group">{{group}}</p>
              {{/group}}
            </div>
            <span class="status-badge status-badge-{{statusClass}}">{{statusLabel}}</span>
          </div>
          {{#hasResult}}
          <div class="popover-details">
            <div class="detail-row">
              <span class="detail-label">Response</span>
              <span class="detail-value">{{formattedDuration}}</span>
            </div>
            {{#httpStatus}}
            <div class="detail-row">
              <span class="detail-label">HTTP</span>
              <span class="detail-value">{{httpStatus}}</span>
            </div>
            {{/httpStatus}}
            <div class="detail-row">
              <span class="detail-label">Checked</span>
              <span class="detail-value">{{formattedTimestamp}}</span>
            </div>
            {{#hasConditions}}
            <div class="conditions-section">
              <p class="conditions-title">Conditions</p>
              <ul class="conditions-list">
                {{#conditions}}
                <li class="condition-item">
                  <span class="{{iconClass}}">{{icon}}</span>
                  <code class="condition-text" title="{{condition}}">{{condition}}</code>
                </li>
                {{/conditions}}
              </ul>
            </div>
            {{/hasConditions}}
          </div>
          {{/hasResult}}
          {{^hasResult}}
          <p class="no-results">No health check results available</p>
          {{/hasResult}}
        </div>
        {{/endpoints}}
      </div>
    </template>

    <!-- Main container with HTMX -->
    <div
      id="app"
      hx-ext="client-side-templates"
      hx-get="/api/v1/endpoints/statuses"
      hx-trigger="load, every 30s"
      mustache-array-template="endpoints-template"
    >
      <div class="loading-container">
        <div class="loading-spinner"></div>
      </div>
    </div>

    <script>
      /**
       * Format nanoseconds to human-readable duration
       * @param {number} nanoseconds
       * @returns {string}
       */
      function formatDuration(nanoseconds) {
        const ms = nanoseconds / 1_000_000;
        if (ms < 1) {
          return Math.round(nanoseconds / 1000) + 'us';
        }
        if (ms < 1000) {
          return Math.round(ms) + 'ms';
        }
        const seconds = ms / 1000;
        if (seconds < 60) {
          return seconds.toFixed(1) + 's';
        }
        const minutes = seconds / 60;
        return minutes.toFixed(1) + 'm';
      }

      /**
       * Format ISO timestamp to relative time
       * @param {string} isoString
       * @returns {string}
       */
      function formatTimestamp(isoString) {
        const date = new Date(isoString);
        if (isNaN(date.getTime())) {
          return 'Unknown';
        }
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffSeconds = Math.floor(diffMs / 1000);
        const diffMinutes = Math.floor(diffSeconds / 60);
        const diffHours = Math.floor(diffMinutes / 60);

        if (diffHours >= 24) {
          return date.toLocaleDateString(undefined, {
            month: 'short',
            day: 'numeric',
            year: 'numeric',
          });
        }
        if (diffMs < 0) {
          return 'just now';
        }
        if (diffSeconds < 60) {
          return diffSeconds <= 5 ? 'just now' : diffSeconds + 's ago';
        }
        if (diffMinutes < 60) {
          return diffMinutes + 'm ago';
        }
        return diffHours + 'h ago';
      }

      /**
       * Preprocess API data for Mustache template
       * @param {Array} endpoints
       * @returns {Object}
       */
      function preprocessEndpoints(endpoints) {
        return {
          endpoints: endpoints.map((endpoint, index) => {
            const latestResult = endpoint.results && endpoint.results[0];
            let statusClass = 'unknown';
            let statusLabel = 'Unknown';

            if (latestResult) {
              if (latestResult.success) {
                statusClass = 'healthy';
                statusLabel = 'Healthy';
              } else {
                statusClass = 'unhealthy';
                statusLabel = 'Unhealthy';
              }
            }

            const result = {
              index: index,
              name: endpoint.name,
              group: endpoint.group || null,
              key: endpoint.key,
              statusClass: statusClass,
              statusLabel: statusLabel,
              hasResult: !!latestResult,
            };

            if (latestResult) {
              result.formattedDuration = formatDuration(latestResult.duration);
              result.formattedTimestamp = formatTimestamp(latestResult.timestamp);
              result.httpStatus = latestResult.status || null;
              result.hasConditions = latestResult.conditionResults && latestResult.conditionResults.length > 0;
              if (result.hasConditions) {
                result.conditions = latestResult.conditionResults.map(cr => ({
                  condition: cr.condition,
                  icon: cr.success ? '\u2713' : '\u2717',
                  iconClass: cr.success ? 'condition-icon-success' : 'condition-icon-failure',
                }));
              }
            }

            return result;
          }),
        };
      }

      // Register preprocessor with HTMX client-side-templates
      document.body.addEventListener('htmx:configRequest', function(event) {
        // Ensure JSON response type
        event.detail.headers['Accept'] = 'application/json';
      });

      document.body.addEventListener('htmx:beforeSwap', function(event) {
        // Check if this is our endpoints request
        if (event.detail.target.id === 'app' && event.detail.xhr.responseURL.includes('/api/v1/endpoints/statuses')) {
          try {
            const data = JSON.parse(event.detail.xhr.responseText);
            const processed = preprocessEndpoints(data);
            // Replace the response with preprocessed data
            event.detail.serverResponse = JSON.stringify(processed);
          } catch (e) {
            console.error('Failed to preprocess endpoints:', e);
          }
        }
      });
    </script>
  </body>
</html>
